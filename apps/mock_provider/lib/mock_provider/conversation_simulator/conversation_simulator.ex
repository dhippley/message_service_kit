defmodule MockProvider.ConversationSimulator do
  @moduledoc """
  Simulates SMS conversations by making API calls to the messaging_service app.
  This module creates realistic back-and-forth conversations for testing purposes.
  """

  alias MockProvider.SimulationGenerator

  require Logger

  @messaging_service_base_url "http://localhost:4000/api"
  @default_conversation_scenarios [
    %{
      name: "chaos",
      # Will be generated dynamically
      participants: :random,
      # Will be generated dynamically
      messages: :random
    },
    %{
      name: "lotr_black_gate",
      # Will be generated by SimulationGenerator
      participants: :dynamic,
      # Will be generated by SimulationGenerator
      messages: :dynamic
    },
    %{
      name: "ghostbusters_elevator",
      # Will be generated by SimulationGenerator
      participants: :dynamic,
      # Will be generated by SimulationGenerator
      messages: :dynamic
    }
  ]

  def simulate_conversation(conn) do
    with {:ok, params} <- parse_request_params(conn),
         {:ok, scenario} <- get_scenario(params),
         :ok <- execute_conversation(scenario) do
      conn
      |> Plug.Conn.put_resp_content_type("application/json")
      |> Plug.Conn.send_resp(
        200,
        Jason.encode!(%{
          status: "success",
          message: "Conversation simulation started",
          scenario: scenario.name,
          participants: scenario.participants,
          message_count: length(scenario.messages)
        })
      )
    else
      {:error, reason} ->
        Logger.error("Conversation simulation failed: #{inspect(reason)}")

        conn
        |> Plug.Conn.put_resp_content_type("application/json")
        |> Plug.Conn.send_resp(
          400,
          Jason.encode!(%{
            status: "error",
            message: reason
          })
        )
    end
  end

  defp parse_request_params(conn) do
    case conn.body_params do
      %{"scenario" => scenario} when is_binary(scenario) ->
        {:ok, %{scenario: scenario}}

      %{} ->
        {:ok, %{scenario: "random"}}

      _ ->
        {:error, "Invalid request format"}
    end
  end

  defp get_scenario(%{scenario: "random"}) do
    scenario = Enum.random(@default_conversation_scenarios)

    # If it's a dynamic scenario, generate content
    cond do
      scenario.name == "chaos" ->
        {:ok, SimulationGenerator.generate_chaos_scenario()}

      scenario.name == "lotr_black_gate" ->
        {:ok, SimulationGenerator.generate_lotr_black_gate_scenario()}

      scenario.name == "ghostbusters_elevator" ->
        {:ok, SimulationGenerator.generate_ghostbusters_elevator_scenario()}

      true ->
        {:ok, scenario}
    end
  end

  defp get_scenario(%{scenario: scenario_name}) do
    case scenario_name do
      "chaos" ->
        {:ok, SimulationGenerator.generate_chaos_scenario()}

      "lotr_black_gate" ->
        {:ok, SimulationGenerator.generate_lotr_black_gate_scenario()}

      "ghostbusters_elevator" ->
        {:ok, SimulationGenerator.generate_ghostbusters_elevator_scenario()}

      _ ->
        case Enum.find(@default_conversation_scenarios, &(&1.name == scenario_name)) do
          nil -> {:error, "Scenario '#{scenario_name}' not found"}
          scenario -> {:ok, scenario}
        end
    end
  end

  defp execute_conversation(scenario) do
    Logger.info("Starting conversation simulation: #{scenario.name}")

    # Spawn a process to handle the conversation asynchronously
    Task.start(fn ->
      Enum.each(scenario.messages, fn message ->
        if message.delay > 0 do
          Process.sleep(message.delay)
        end

        send_message(message)
      end)

      Logger.info("Completed conversation simulation: #{scenario.name}")
    end)

    :ok
  end

  defp send_message(message) do
    # Send message with recipients as a list (group messaging)
    case message.endpoint do
      "api" -> send_via_api(message)
      "webhook" -> send_via_webhook(message)
      _ -> {:error, "Unknown endpoint: #{message.endpoint}"}
    end
  end

  defp send_via_api(message) do
    case send_sms_to_messaging_service(message) do
      {:ok, response} ->
        recipients = if is_list(message.to), do: Enum.join(message.to, ", "), else: message.to
        Logger.info("Sent API message: #{message.body} (#{message.from} -> #{recipients})")
        {:ok, response}

      {:error, reason} ->
        Logger.error("Failed to send API message: #{inspect(reason)}")
        {:error, reason}
    end
  end

  defp send_via_webhook(message) do
    case send_webhook_to_messaging_service(message) do
      {:ok, response} ->
        recipients = if is_list(message.to), do: Enum.join(message.to, ", "), else: message.to
        Logger.info("Sent webhook message: #{message.body} (#{message.from} -> #{recipients})")
        {:ok, response}

      {:error, reason} ->
        Logger.error("Failed to send webhook message: #{inspect(reason)}")
        {:error, reason}
    end
  end

  defp send_sms_to_messaging_service(message) do
    url = "#{@messaging_service_base_url}/messages/sms"

    payload = %{
      to: message.to,
      from: message.from,
      body: message.body
    }

    case Req.post(url, json: payload) do
      {:ok, %{status: 201, body: body}} ->
        {:ok, body}

      {:ok, %{status: status_code, body: body}} ->
        {:error, "HTTP #{status_code}: #{inspect(body)}"}

      {:error, reason} ->
        {:error, "Network error: #{inspect(reason)}"}
    end
  rescue
    exception ->
      {:error, "Exception occurred: #{inspect(exception)}"}
  end

  defp send_webhook_to_messaging_service(message) do
    url = "#{@messaging_service_base_url}/webhooks/sms"

    # Webhook payload format (using lowercase keys expected by the controller)
    payload = %{
      from: message.from,
      to: message.to,  # Send the 'to' field as-is (can be string or list)
      body: message.body,
      provider_id: "SM#{:rand.uniform(100_000_000_000_000_000_000_000_000_000_000)}",
      type: "sms"
    }

    headers = [
      {"authorization", "ApiKey dev-api-key-123"}
    ]

    case Req.post(url, json: payload, headers: headers) do
      {:ok, %{status: 200, body: body}} ->
        {:ok, body}

      {:ok, %{status: status_code, body: body}} ->
        {:error, "HTTP #{status_code}: #{inspect(body)}"}

      {:error, reason} ->
        {:error, "Network error: #{inspect(reason)}"}
    end
  rescue
    exception ->
      {:error, "Exception occurred: #{inspect(exception)}"}
  end

  @doc """
  Returns a list of available conversation scenarios.
  """
  def list_scenarios do
    Enum.map(@default_conversation_scenarios, fn scenario ->
      %{
        name: scenario.name,
        participants: get_scenario_participants(scenario.name),
        message_count: get_scenario_message_count(scenario.name),
        description: get_scenario_description(scenario.name)
      }
    end)
  end

  defp get_scenario_participants("chaos"), do: ["Random phone numbers"]
  defp get_scenario_participants("lotr_black_gate"), do: ["+15551234567", "+15551234568"]
  defp get_scenario_participants("ghostbusters_elevator"), do: ["+15551234567", "+15551234568", "+15551234569"]
  defp get_scenario_participants(_), do: ["Unknown"]

  defp get_scenario_message_count("chaos"), do: "5-10 random messages"
  defp get_scenario_message_count("lotr_black_gate"), do: 8
  defp get_scenario_message_count("ghostbusters_elevator"), do: 7
  defp get_scenario_message_count(_), do: "Variable"

  defp get_scenario_description("chaos"),
    do: "Random participants having a conversation with completely random word combinations"

  defp get_scenario_description("lotr_black_gate"),
    do: "Epic dialogue between Aragorn and the Mouth of Sauron at the Black Gate of Mordor"

  defp get_scenario_description("ghostbusters_elevator"),
    do: "Classic Ghostbusters elevator scene about untested proton pack equipment"

  defp get_scenario_description(_), do: "Custom conversation scenario"

  @doc """
  Starts a stress test by sending a large number of random scenarios asynchronously.
  """
  def stress_test(conn) do
    case parse_stress_test_params(conn) do
      {:ok, params} ->
        # Start stress test asynchronously
        test_id = generate_test_id()

        Task.start(fn ->
          Logger.info("Starting stress test: #{test_id} with #{params.scenario_count} scenarios")
          execute_stress_test(test_id, params)
        end)

        conn
        |> Plug.Conn.put_resp_content_type("application/json")
        |> Plug.Conn.send_resp(
          200,
          Jason.encode!(%{
            status: "success",
            message: "Stress test started",
            test_id: test_id,
            scenario_count: params.scenario_count,
            concurrent_workers: params.concurrent_workers,
            delay_between_batches: params.delay_between_batches
          })
        )

      {:error, reason} ->
        Logger.error("Stress test failed to start: #{inspect(reason)}")

        conn
        |> Plug.Conn.put_resp_content_type("application/json")
        |> Plug.Conn.send_resp(
          400,
          Jason.encode!(%{
            status: "error",
            message: reason
          })
        )
    end
  end

  defp parse_stress_test_params(conn) do
    params = conn.body_params || %{}

    scenario_count = Map.get(params, "scenario_count", 1000)
    concurrent_workers = Map.get(params, "concurrent_workers", 10)
    delay_between_batches = Map.get(params, "delay_between_batches", 100)
    scenario_types = Map.get(params, "scenario_types", ["chaos", "lotr_black_gate", "ghostbusters_elevator"])

    # Validate parameters
    cond do
      not is_integer(scenario_count) or scenario_count < 1 or scenario_count > 10_000 ->
        {:error, "scenario_count must be between 1 and 10000"}

      not is_integer(concurrent_workers) or concurrent_workers < 1 or concurrent_workers > 50 ->
        {:error, "concurrent_workers must be between 1 and 50"}

      not is_integer(delay_between_batches) or delay_between_batches < 0 ->
        {:error, "delay_between_batches must be >= 0"}

      not is_list(scenario_types) or Enum.empty?(scenario_types) ->
        {:error, "scenario_types must be a non-empty list"}

      true ->
        {:ok,
         %{
           scenario_count: scenario_count,
           concurrent_workers: concurrent_workers,
           delay_between_batches: delay_between_batches,
           scenario_types: scenario_types
         }}
    end
  end

  defp generate_test_id do
    8 |> :crypto.strong_rand_bytes() |> Base.encode16(case: :lower)
  end

  defp execute_stress_test(test_id, params) do
    start_time = System.monotonic_time(:millisecond)

    # Create batches of scenarios
    batch_size = div(params.scenario_count, params.concurrent_workers)
    remaining = rem(params.scenario_count, params.concurrent_workers)

    # Create tasks for concurrent execution
    tasks =
      Enum.map(1..params.concurrent_workers, fn worker_id ->
        scenarios_for_worker =
          if worker_id == params.concurrent_workers do
            batch_size + remaining
          else
            batch_size
          end

        Task.async(fn ->
          execute_worker_batch(test_id, worker_id, scenarios_for_worker, params)
        end)
      end)

    # Wait for all workers to complete and collect results
    results = Task.await_many(tasks, :infinity)

    end_time = System.monotonic_time(:millisecond)
    duration = end_time - start_time

    # Calculate statistics
    total_messages = Enum.sum(results)
    successful_scenarios = length(results)

    Logger.info("Stress test #{test_id} completed:")
    Logger.info("  Duration: #{duration}ms")
    Logger.info("  Scenarios executed: #{successful_scenarios}")
    Logger.info("  Total messages sent: #{total_messages}")
    Logger.info("  Messages per second: #{Float.round(total_messages / (duration / 1000), 2)}")
  end

  defp execute_worker_batch(test_id, worker_id, scenario_count, params) do
    Logger.info("Worker #{worker_id} starting #{scenario_count} scenarios for test #{test_id}")

    total_messages =
      Enum.reduce(1..scenario_count, 0, fn scenario_num, acc ->
        # Generate random scenario
        scenario_type = Enum.random(params.scenario_types)
        {:ok, scenario} = get_scenario(%{scenario: scenario_type})

        # Execute scenario
        Enum.each(scenario.messages, fn message ->
          send_message(message)
        end)

        # Add delay between batches if specified
        if params.delay_between_batches > 0 and rem(scenario_num, 10) == 0 do
          Process.sleep(params.delay_between_batches)
        end

        acc + length(scenario.messages)
      end)

    Logger.info("Worker #{worker_id} completed #{scenario_count} scenarios, sent #{total_messages} messages")
    total_messages
  end
end
