defmodule MockProvider.ConversationSimulator do
  @moduledoc """
  Simulates SMS conversations by making API calls to the messaging_service app.
  This module creates realistic back-and-forth conversations for testing purposes.
  """

  alias MockProvider.SimulationGenerator
  require Logger

  @messaging_service_base_url "http://localhost:4000/api"
  @default_conversation_scenarios [
    %{
      name: "chaos",
      participants: :random,  # Will be generated dynamically
      messages: :random  # Will be generated dynamically
    },
    %{
      name: "lotr_black_gate",
      participants: :dynamic,  # Will be generated by SimulationGenerator
      messages: :dynamic  # Will be generated by SimulationGenerator
    },
    %{
      name: "ghostbusters_elevator",
      participants: :dynamic,  # Will be generated by SimulationGenerator
      messages: :dynamic  # Will be generated by SimulationGenerator
    }
  ]

  def simulate_conversation(conn) do
    with {:ok, params} <- parse_request_params(conn),
         {:ok, scenario} <- get_scenario(params),
         :ok <- execute_conversation(scenario) do

      conn
      |> Plug.Conn.put_resp_content_type("application/json")
      |> Plug.Conn.send_resp(200, Jason.encode!(%{
        status: "success",
        message: "Conversation simulation started",
        scenario: scenario.name,
        participants: scenario.participants,
        message_count: length(scenario.messages)
      }))
    else
      {:error, reason} ->
        Logger.error("Conversation simulation failed: #{inspect(reason)}")
        conn
        |> Plug.Conn.put_resp_content_type("application/json")
        |> Plug.Conn.send_resp(400, Jason.encode!(%{
          status: "error",
          message: reason
        }))
    end
  end

  defp parse_request_params(conn) do
    case conn.body_params do
      %{"scenario" => scenario} when is_binary(scenario) ->
        {:ok, %{scenario: scenario}}

      %{} ->
        {:ok, %{scenario: "random"}}

      _ ->
        {:error, "Invalid request format"}
    end
  end

  defp get_scenario(%{scenario: "random"}) do
    scenario = Enum.random(@default_conversation_scenarios)

    # If it's a dynamic scenario, generate content
    cond do
      scenario.name == "chaos" ->
        {:ok, SimulationGenerator.generate_chaos_scenario()}
      scenario.name == "lotr_black_gate" ->
        {:ok, SimulationGenerator.generate_lotr_black_gate_scenario()}
      scenario.name == "ghostbusters_elevator" ->
        {:ok, SimulationGenerator.generate_ghostbusters_elevator_scenario()}
      true ->
        {:ok, scenario}
    end
  end

  defp get_scenario(%{scenario: scenario_name}) do
    case scenario_name do
      "chaos" ->
        {:ok, SimulationGenerator.generate_chaos_scenario()}

      "lotr_black_gate" ->
        {:ok, SimulationGenerator.generate_lotr_black_gate_scenario()}

      "ghostbusters_elevator" ->
        {:ok, SimulationGenerator.generate_ghostbusters_elevator_scenario()}

      _ ->
        case Enum.find(@default_conversation_scenarios, &(&1.name == scenario_name)) do
          nil -> {:error, "Scenario '#{scenario_name}' not found"}
          scenario -> {:ok, scenario}
        end
    end
  end

  defp execute_conversation(scenario) do
    Logger.info("Starting conversation simulation: #{scenario.name}")

    # Spawn a process to handle the conversation asynchronously
    Task.start(fn ->
      Enum.each(scenario.messages, fn message ->
        if message.delay > 0 do
          Process.sleep(message.delay)
        end

        send_message(message)
      end)

      Logger.info("Completed conversation simulation: #{scenario.name}")
    end)

    :ok
  end

  defp send_message(message) do
    # Send message with recipients as a list (group messaging)
    case message.endpoint do
      "api" -> send_via_api(message)
      "webhook" -> send_via_webhook(message)
      _ -> {:error, "Unknown endpoint: #{message.endpoint}"}
    end
  end

  defp send_via_api(message) do
    case send_sms_to_messaging_service(message) do
      {:ok, response} ->
        recipients = if is_list(message.to), do: Enum.join(message.to, ", "), else: message.to
        Logger.info("Sent API message: #{message.body} (#{message.from} -> #{recipients})")
        {:ok, response}

      {:error, reason} ->
        Logger.error("Failed to send API message: #{inspect(reason)}")
        {:error, reason}
    end
  end

  defp send_via_webhook(message) do
    case send_webhook_to_messaging_service(message) do
      {:ok, response} ->
        recipients = if is_list(message.to), do: Enum.join(message.to, ", "), else: message.to
        Logger.info("Sent webhook message: #{message.body} (#{message.from} -> #{recipients})")
        {:ok, response}

      {:error, reason} ->
        Logger.error("Failed to send webhook message: #{inspect(reason)}")
        {:error, reason}
    end
  end

  defp send_sms_to_messaging_service(message) do
    url = "#{@messaging_service_base_url}/messages/sms"

    payload = %{
      to: message.to,
      from: message.from,
      body: message.body
    }

    case Req.post(url, json: payload) do
      {:ok, %{status: 201, body: body}} ->
        {:ok, body}

      {:ok, %{status: status_code, body: body}} ->
        {:error, "HTTP #{status_code}: #{inspect(body)}"}

      {:error, reason} ->
        {:error, "Network error: #{inspect(reason)}"}
    end
  rescue
    exception ->
      {:error, "Exception occurred: #{inspect(exception)}"}
  end

  defp send_webhook_to_messaging_service(message) do
    url = "#{@messaging_service_base_url}/webhooks/sms"

    # Webhook payload format (using lowercase keys expected by the controller)
    payload = %{
      from: message.from,
      to: message.to,
      body: message.body,
      provider_id: "SM#{:rand.uniform(100000000000000000000000000000000)}",
      type: "sms"
    }

    headers = [
      {"authorization", "ApiKey dev-api-key-123"}
    ]

    case Req.post(url, form: payload, headers: headers) do
      {:ok, %{status: 200, body: body}} ->
        {:ok, body}

      {:ok, %{status: status_code, body: body}} ->
        {:error, "HTTP #{status_code}: #{inspect(body)}"}

      {:error, reason} ->
        {:error, "Network error: #{inspect(reason)}"}
    end
  rescue
    exception ->
      {:error, "Exception occurred: #{inspect(exception)}"}
  end

  @doc """
  Returns a list of available conversation scenarios.
  """
  def list_scenarios do
    Enum.map(@default_conversation_scenarios, fn scenario ->
      %{
        name: scenario.name,
        participants: get_scenario_participants(scenario.name),
        message_count: get_scenario_message_count(scenario.name),
        description: get_scenario_description(scenario.name)
      }
    end)
  end

  defp get_scenario_participants("chaos"), do: ["Random phone numbers"]
  defp get_scenario_participants("lotr_black_gate"), do: ["+15551234567", "+15551234568"]
  defp get_scenario_participants("ghostbusters_elevator"), do: ["+15551234567", "+15551234568", "+15551234569"]
  defp get_scenario_participants(_), do: ["Unknown"]

  defp get_scenario_message_count("chaos"), do: "5-10 random messages"
  defp get_scenario_message_count("lotr_black_gate"), do: 8
  defp get_scenario_message_count("ghostbusters_elevator"), do: 7
  defp get_scenario_message_count(_), do: "Variable"

  defp get_scenario_description("chaos"), do: "Random participants having a conversation with completely random word combinations"
  defp get_scenario_description("lotr_black_gate"), do: "Epic dialogue between Aragorn and the Mouth of Sauron at the Black Gate of Mordor"
  defp get_scenario_description("ghostbusters_elevator"), do: "Classic Ghostbusters elevator scene about untested proton pack equipment"
  defp get_scenario_description(_), do: "Custom conversation scenario"
end
